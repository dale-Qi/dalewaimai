# 基于Springboot+redis+SSM（spring +SpringMVC+mybais）的后端外卖项目学习（已结束）

# 2025.6.14

## Spring Boot 常见的三层架构是这样的：

```
text
复制编辑
Controller（控制层）→ Service（业务逻辑层）→ Repository（持久层 / DAO）→ 数据库
```

示意图如下：

```
text复制编辑     
	 ┌────────────┐
     │ Controller │  <- 接收请求
     └────┬───────┘
          ↓
     ┌────────────┐
     │  Service   │  <- 处理业务逻辑
     └────┬───────┘
          ↓
     ┌────────────┐
     │ Repository │  <- 操作数据库（持久层）
     └────┬───────┘
          ↓
     ┌────────────┐
     │  Database  │
     └────────────┘
```

**持久层就是你和数据库沟通的专职模块**，你通过 Repository（接口）操作数据库，让数据“持久”地保存在磁盘中。

### mapper使用

Mapper 的概念

1. **方法⇄SQL 映射**
    每个 Mapper 接口中的方法都对应一条或多条 SQL。在调用该方法时，MyBatis 会找到并执行对应的 SQL。
2. **结果⇄对象 映射**
    SQL 执行后返回的 ResultSet（结果集）会被 MyBatis 自动转换成你在方法签名中声明的 Java 对象或集合。
3. **配置与注解**
    你既可以通过 XML 文件来编写 SQL，也可以在接口方法上直接使用注解（如 `@Select`、`@Insert`）



# 6.15 处理昨天的几个员工登录问题

## 在登入相同用户名后要抛异常

使用全局异常处理器GlobalExceptionHandler.java来捕获异常

## 在新增时，创建和修改人id设为固定

动态获取登录用户id

基于jwt令牌认证流程：

**用户登录成功**：
 后端生成包含用户 ID（如 empId）的 JWT 令牌，并返回给前端。

**前端存储 Token 并发送请求**：
 前端将 token 保存在本地（如 LocalStorage）中，后续每次请求接口时，将 token 放在请求头中（通常是 `Authorization` 字段，格式如 `Bearer xxx`）。

**后端接收到请求后解析 Token**：
 后端通过拦截器或过滤器，从请求头中获取 token 并进行解析，提取出其中的用户 ID（例如 empId 字段）。

**将用户 ID 存入上下文**：
 为了让后续的业务代码可以方便使用，后端会将提取出的用户 ID 存入 ThreadLocal 等上下文容器中。

**在 Controller 或 Service 层获取当前用户 ID**：
 业务代码中就可以通过上下文工具类直接获取当前登录用户的 ID，执行用户相关逻辑。

## threadlocal（客户端发出的每一次请求到后端的线程id都是相同的）

一、ThreadLocal 是什么？

> `ThreadLocal` 是 Java 提供的一种线程本地变量，**它为每一个线程提供独立的变量副本**。

简单理解就是：

- 普通变量是**多个线程共享一份数据**；
- 而 `ThreadLocal` 是**每个线程各自保存一份独立的数据副本**，互不干扰。

二、为什么需要 ThreadLocal？

在 Web 后端开发中，比如 SpringBoot 处理一个 HTTP 请求时：

- 每个请求由一个独立的线程处理；
- 我们可能需要在整个请求过程中 **共享一些上下文数据**（例如登录用户 ID），但又不希望不同请求互相影响；
- 此时就可以把这些数据保存在 `ThreadLocal` 中，做到 **线程隔离 + 数据共享**。

## 注意到的问题：请求头部

在进行新增员工接口测试时，由于这个接口是需要在登录后才能使用，所以应该先登录接口返回一个token，把它作为全局变量，交给新增员工，注意，这个token每次会变

什么是请求头部（HTTP Header）？

在一次 **HTTP 请求中**，请求分为以下几部分：

```
mathematica复制编辑请求行（Request Line）
请求头（Request Headers）✅
空行
请求体（Request Body）（如 POST 的 JSON）
```

**请求头部（Headers）**：用于描述客户端的信息、请求格式、认证信息等。后端在接收到请求时，会先解析这些头部信息，决定如何处理请求。

# 6.16员工管理和分类管理开发结束，今日学习公共字段自动填充

## 所谓公共字段

员工分类菜品套餐表中，都有公共字段，如：create_time(创建时间)，create_user（创建人），update_time（更新时间），update_user（更新人）

每次在新增员工，菜品等内容时候，都要手动设置，会使代码的健壮性不高，冗余性太高

## 解决方法

自定义注解 AutoFil，用于标识需要进行公共字段自动填充的方法
自定义切面类 AutoFiAspect，统一拦截加入了 AutoFi 注解的方法，通过反射为公共字段赋值

在mapper上加入AutoFill

# 6.30 关于Redis

## 🔧 一、Redis 是什么？

**Redis**（Remote Dictionary Server）是一个开源的、**基于内存的高性能键值数据库（Key-Value Store）**，也被称为 “数据结构服务器”。

### ✅ 主要特点：

| 特性                | 说明                                           |
| ------------------- | ---------------------------------------------- |
| 内存存储            | 所有数据保存在内存中，读写非常快（毫秒级）     |
| 数据结构丰富        | 不仅仅是 key-value，还支持字符串、哈希、列表等 |
| 持久化支持          | 可将数据保存到磁盘中（RDB、AOF）               |
| 支持发布/订阅       | 可用于实现消息队列、通知机制                   |
| 支持分布式          | 可以构建 Redis Cluster，做横向扩展             |
| 支持事务和 Lua 脚本 | 可实现复杂的原子操作                           |



------

## 🤔 二、为什么 Java 要用 Redis？

在 Java 后端系统中，Redis 常常作为 **缓存** 或 **高性能辅助存储工具** 来使用，主要解决 **数据库压力大、请求响应慢** 的问题。

### ✅ Java 中使用 Redis 的典型场景：

| 场景                  | 说明                                        |
| --------------------- | ------------------------------------------- |
| ✅ 缓存热点数据        | 如用户信息、商品详情等，减少数据库访问压力  |
| ✅ 分布式锁            | 使用 Redis 实现互斥控制，控制并发操作       |
| ✅ 计数器/限流器       | 秒杀抢购、API 限流、点赞计数等              |
| ✅ 会话存储（Session） | 前端用户登录信息存在 Redis（如 JWT 黑名单） |
| ✅ 消息队列/发布订阅   | 利用 Redis 的 pub/sub 功能实现异步通知      |
| ✅ 排行榜/推荐系统     | 利用 Redis 的有序集合实现                   |



------

## 📦 三、Redis 的常用数据结构

Redis 的强大之处在于它支持多种丰富的数据结构。下面是最常用的几种：

| 类型                 | 命令示例                                       | 说明与 Java 使用场景                                         |
| -------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| **String**           | `SET key value` `GET key`                      | 最基本的键值对，支持数字、JSON 等 ✅ 用于缓存用户Token、对象序列化等 |
| **Hash**             | `HSET user:1 name zhangsan` `HGET user:1 name` | 类似 Java 的 Map，常用于缓存对象字段                         |
| **List**             | `LPUSH list val` `RPOP list`                   | 有序链表，可做消息队列，聊天记录缓存                         |
| **Set**              | `SADD key val` `SISMEMBER key val`             | 无序集合，适合去重操作，如点赞用户集合                       |
| **ZSet**（有序集合） | `ZADD key score val` `ZRANGE key 0 -1`         | 排行榜/打分系统，按 score 排序的集合                         |
| **Bitmap**           | `SETBIT key offset value`                      | 位图，适合用于签到、活跃用户标记等                           |
| **HyperLogLog**      | `PFADD key element`                            | 用于估算去重计数，节省内存                                   |
| **Geo**              | `GEOADD key lon lat member`                    | 存储地理位置，可用于附近搜索                                 |
| **Pub/Sub**          | `PUBLISH channel msg` `SUBSCRIBE channel`      | 发布/订阅模式，适合通知推送、事件流                          |



------

## ⚙️ 四、Java 中如何使用 Redis？

在 Java 项目中使用 Redis，常用的方式包括：

| 技术栈/工具                     | 简介                                                   |
| ------------------------------- | ------------------------------------------------------ |
| **Spring Boot + Redis Starter** | 最常见的方式，配置简单，自动注入 `StringRedisTemplate` |
| **Jedis**                       | Redis 的原始 Java 客户端，API 丰富但配置略复杂         |
| **Lettuce**                     | 基于 Netty 的客户端，性能更好，Spring 默认使用         |
| **Redisson**                    | Redis 的高级封装库，支持分布式锁、限流、任务调度等功能 |

## 该项目使用到redis进行设置店铺销售状态（运营中/打烊中）

由于该状态仅使用一个status进行传参，使用mysql数据库过于繁琐，因此使用redis缓存更加快捷方便

# 7.1 Httpclient&小程序开发

## 🧠 一、HttpClient 是什么？

**HttpClient** 是 Java 中用于发送 HTTP 请求的工具，可以让你像浏览器一样去请求服务器（如后端请求另一个服务、请求第三方接口）。

> 简单说：**它是“Java 程序里的浏览器”**，可以访问网站、调用 REST 接口、上传表单等。

------

## ✅ 二、HttpClient 的常用用途

| 场景                           | 举例                                        |
| ------------------------------ | ------------------------------------------- |
| 后端向另一个服务发起 HTTP 请求 | 服务 A 向 服务 B 发送用户数据（微服务通信） |
| 调用第三方 API 接口            | 如微信支付、阿里云短信、百度地图等          |
| 自动化测试接口                 | 写脚本批量访问多个接口、对比响应内容        |
| 爬虫获取网页内容（合法前提下） | 抓取网站数据进行分析                        |



------

## 🧰 三、HttpClient 的常见实现方式

Java 中有多种 HttpClient 实现：

| 实现库                            | 特点                              |
| --------------------------------- | --------------------------------- |
| **Java 原生 `HttpURLConnection`** | 最底层，冗长，不推荐新项目使用    |
| **Apache HttpClient**             | 功能强大，老牌工具，社区成熟      |
| **Spring 的 `RestTemplate`**      | 封装良好，适合 Spring 项目        |
| **Spring WebClient**（新）        | 支持响应式编程，Spring 5 推荐     |
| **OkHttp（第三方库）**            | 简洁高效，广泛用于 Android 和后端 |

# 7.2使用redis缓存来降低用户端频繁访问数据库造成的压力

学习到day7，已转去java+AI项目
